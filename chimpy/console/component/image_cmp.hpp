#pragma once#include <iostream>#include "../include/stb_image.h"#include "component.hpp"namespace Core{class ImageCmp : public Component{private:  GLuint texture_;public:  ImageCmp(const std::string& component_name, const std::string& image_name) : Component(component_name)  {    texture_ = loadTexture(image_name.c_str());  }public:  void render(float display_w, float display_h) override  {    ImGui::Begin(render_name_.c_str());    resizeRightButton(display_w, display_h);    ImGui::Image((ImTextureID)(intptr_t)texture_, ImVec2(display_w * size_w_, size_h_ * display_h));    ImGui::End();  }private:  GLuint loadTexture(const char* filename, int custom_width = 0, int custom_height = 0)  {    int width, height, channels;    unsigned char* data = stbi_load(filename, &width, &height, &channels, 0);    if (data == nullptr)    {      std::cerr << "Failed to load texture: " << filename << std::endl;      return 0;    }    if (custom_width == 0)      custom_width = width;    if (custom_height == 0)      custom_height = height;    GLuint textureID;    glGenTextures(1, &textureID);    glBindTexture(GL_TEXTURE_2D, textureID);    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, custom_width, custom_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);    stbi_image_free(data);    return textureID;  }};}  // namespace Core