#pragma once#include <algorithm>#include <atomic>#include <cmath>#include <filesystem>#include <functional>#include <memory>#include <string>#include <thread>#include <vector>#include "component.hpp"#include "text_cmp.hpp"namespace Core{template <typename T>class DisplayDirectoryCmp : public Component{private:  struct DirectoryNode  {    std::string full_path_;    std::string file_name_;    std::vector<DirectoryNode> children_;    bool is_directory_;  };  DirectoryNode root_node_;  std::string selected_file_path_;  T render_after_selected_;public:  template <typename... Args>  DisplayDirectoryCmp(const std::string& name, Args&&... args)      : Component(name),        root_node_(createDirectryNodeTreeFromPath(L"/home/antilopa/Projects/Cpp/Labs/Sem3-Lab2")),        render_after_selected_(std::move(args)...)  {  }  void render(float display_w, float display_h) override  {    if (ImGui::Begin("Directory Tree Window", nullptr, ImGuiWindowFlags_NoSavedSettings))    {      resizeLeftButton(display_w, display_h);      ImGui::TextWrapped("Choose file to index and sort...");      recursivelyAddDirectoryNodes(root_node_);    }    ImGui::End();  }private:  void recursivelyAddDirectoryNodes(DirectoryNode& parent_node, std::filesystem::directory_iterator directory_iterator)  {    for (const std::filesystem::directory_entry& entry : directory_iterator)    {      DirectoryNode& childNode = parent_node.children_.emplace_back();      childNode.full_path_ = entry.path().string();      childNode.file_name_ = entry.path().filename().string();      if (childNode.is_directory_ = entry.is_directory(); childNode.is_directory_)        recursivelyAddDirectoryNodes(childNode, std::filesystem::directory_iterator(entry));    }    auto moveDirectoriesToFront = [](const DirectoryNode& a, const DirectoryNode& b)    { return (a.is_directory_ > b.is_directory_); };    std::sort(parent_node.children_.begin(), parent_node.children_.end(), moveDirectoriesToFront);  }private:  DirectoryNode createDirectryNodeTreeFromPath(const std::filesystem::path& root_path)  {    DirectoryNode root_node;    root_node.full_path_ = root_path.string();    root_node.file_name_ = root_path.filename().string();    if (root_node.is_directory_ = std::filesystem::is_directory(root_path); root_node.is_directory_)      recursivelyAddDirectoryNodes(root_node, std::filesystem::directory_iterator(root_path));    return root_node;  }private:  void recursivelyAddDirectoryNodes(const DirectoryNode& parent_node)  {    ImGui::PushID(&parent_node);    if (parent_node.is_directory_)    {      if (ImGui::TreeNodeEx(parent_node.file_name_.c_str(), ImGuiTreeNodeFlags_SpanFullWidth))      {        for (const DirectoryNode& childNode : parent_node.children_) recursivelyAddDirectoryNodes(childNode);        ImGui::TreePop();      }    }    else    {      bool is_selected = (parent_node.full_path_ == selected_file_path_);      if (is_selected)      {        ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.2f, 0.6f, 0.8f, 1.0f));        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 1.0f, 1.0f));      }      if (ImGui::Selectable(parent_node.file_name_.c_str(), is_selected, ImGuiSelectableFlags_SpanAllColumns))      {        selected_file_path_ = parent_node.full_path_;      }      if (is_selected)      {        ImGui::PopStyleColor(2);      }      // if (ImGui::IsItemClicked())      // {      // }      if (is_selected)      {        render_after_selected_.renderFilePath(selected_file_path_);      }    }    ImGui::PopID();  }};}  // namespace Core